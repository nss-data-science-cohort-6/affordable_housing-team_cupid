---
title: "R Notebook"
output: html_notebook
---

This is an [R Markdown](http://rmarkdown.rstudio.com) Notebook. When you execute code within the notebook, the results appear beneath the code. 

Try executing this chunk by clicking the *Run* button within the chunk or by placing your cursor inside it and pressing *Ctrl+Shift+Enter*. 

```{r}
library(sf)
library(leaflet)
library(htmltools)
library(scales)

library(tidyverse)
library(ggplot2)
library(dplyr)
library(readr)
library(tibble)
```

#### Reading the data files
#### Note we are using the LITHC updated files where the YR_PIS in the 5th row is changed from 9999 to 2017.
#### The top five rows YR_PIS has 8888 and 9999 values in LIHTC data set.

```{r}
filtered_sales <- read_csv('./data/filtered_sales.csv')
LIHTC <- read_csv('./data/LIHTC_updated.csv')
property_details <- read_csv('./data/property_details.csv')
barnes <- read_csv('./data/barnes_fixed.csv')
assessments <- read_csv('./data/assessments.csv')
```

```{r}
head(property_details) #looking at the head of the property_sales
str(property_details) #finding the nature of the 

property_details$latlong <- stringr::str_extract(string = property_details$centroid,
                                               pattern = "(?<=\\().*(?=\\))")
#head(property_details)
#str(property_details)
```

#### Making the longitude and latitude column from the latlong created from centriod column so that it can be used for sf (simple form) object creation
`
```{r}
library(stringr)
property_details[c('long', 'lat')] <- str_split_fixed(property_details$latlong,
                                                      ',', 2)

```

#### Cleaning the LIHTC file removing the rows with YR_PIS as 8888 and 9999 which have no meaning full YR_PIS.
#### Also filtering out the development which are commited to service before year 2000


```{r}
lihtc_2000 <- LIHTC %>%
  filter(YR_PIS >= 2000)%>%
  filter(YR_PIS != 8888, YR_PIS != 9999)
lihtc2000_mod <- lihtc_2000[, c('HUD_ID', 'PROJECT', 'YR_PIS','LATITUDE', 'LONGITUDE')] 
lihtc2000_mod
```

#### From 177 rows we are now down to 57 housing developments to compare with the property sales data. Also we created a new data from lihtc2000_mod with just the 5 columns, for merging to barnes and analysis.

#### preparing the barnes data to be merged with the LIHTC so that it can be used for property analysis. (Note: we filled the missing property names in Barnes data using google serach and created the HUDID column in .csv before reading it). 
#### fix the date format from mm/dd/yyyy to only yyyy and it is a character to make it numeric, change the column names and keep only the five coulms needed to row bind with lihtc2000_mod

```{r}
barnes$'Affordability Term Start Date' <- str_sub(barnes$'Affordability Term Start Date', start=-4, end=-1) %>%
  as.numeric()

str(barnes$`Affordability Term Start Date`)

barnes_mod <- barnes[, c('HUD_ID', 'Development Name', 'Affordability Term Start Date', 'lat', 'lng')]

barnes_mod

# Rename the columns to match the LIHTC
colnames(barnes_mod) <- c('HUD_ID', 'PROJECT', 'YR_PIS','LATITUDE', 'LONGITUDE')
barnes_mod
```

#### barnes data is ready to row bind to the lihtc

```{r}
developments <- rbind(lihtc2000_mod, barnes_mod)
developments
```


#### From 177 rows we are now down to 57 housing developments which becmes 65 upon ading the barnes data. This is ready to converted into sf-object.

#### We are going to work on merging the property_sales to the filtered_sales.
#### Filtered sales has some duplicate rows we will drop the duplicates using distinct() function and then do the inner_join to the property sales, to keep all the common rows we will use the 'apn' as the joining column and then we will convert the tibbles to sf objects, to find the distance from housing development.

```{r}
dropdup_fs <- filtered_sales %>%
  distinct()

sale_prop_details <- inner_join(dropdup_fs, property_details, by="apn")
```


#### Convert the tibbles the sale+property details and developemnts into sf object for distance comparison and finding the nearest housing development to the property.
#### sf object needs the longitute and latitude column. That is used for craeting geometry. Geoemtry we will use for finding the distance from Low income housing (LIHTC).

```{r}
dev_sf = st_as_sf(developments, coords = c("LONGITUDE", "LATITUDE"), 
                 crs = 4326)
prop_sales_sf = st_as_sf(sale_prop_details, coords = c('long', 'lat'),
                         crs = 4326)

```

#### Now we have the sf objects we are going to compare the geometry columns across the data sets lihtc_sf and prop_sales_sf to find the nearest housing development and the distance from that to the property.

### We will find the property within 0.5 miles and 1 miles distance.
### get the nearest proeprty in a vector called nearest
### calcukate the distance from nearest into dist and convert meters into miles
### column bind the two sf_objects prop_sales and the developemnts, and drop the geometry for prop_sales
### Add the dist vector into the combined tibbles as column.


```{r}
nearest <- st_nearest_feature(prop_sales_sf, dev_sf)
#nearest
dist <- st_distance(prop_sales_sf, 
                    dev_sf[nearest,], by_element = TRUE) %>%
    units::set_units(mi)

```


```{r}
# Map property  to nearest housing development
properties_to_AH <- bind_cols(prop_sales_sf %>% st_drop_geometry(), 
                                dev_sf[nearest, ])

#str(properties_to_AH)
#summary(properties_to_AH)
```

#### create the distance coulmn as dist in the combine data set with the st_nearest_feature

```{r}
properties_to_AH$dist = dist

properties_to_AH <- properties_to_AH %>% 
  mutate(dist = as.numeric(dist))
#properties_to_AH <- properties_to_AH$dist %>%
 # as.numeric()
  
```


#### Filter and create the data set only to have the properties that are within one miles diameter of the low income housing developemnt using the dist column.


```{r}
prop_within_1mile <- properties_to_AH %>%
  filter(dist <= 1)
prop_within_1mile

```

#### The ownerdate is a date object has the yyyy-mm-dd format so going to form the numeric column to have only yyyy so that we can find the number of years the property was sold with respect to when it was built and when the low income housing was released for service.


```{r}
prop_within_1mile$ownerdate <- prop_within_1mile$ownerdate %>% 
  format(format = "%Y") %>% 
  as.numeric()

str(prop_within_1mile)
summary(prop_within_1mile)
```

#### Going to create the difference coulmn substracting the sales date (owner_date) from the Housing development data put in service (YR_PIS). 
#### using the diff (YR_PIS - ownerdate) and dist (distance from the housing development in mles) we will make the grouping for less than 5 miles and different years

```{r}
prop_within_1mile <- prop_within_1mile %>%
  mutate (difference = (YR_PIS - ownerdate),
          age = (ownerdate - year_built))


prop_within_1mile <- prop_within_1mile %>%
  mutate(group = 
           case_when(
             dist < 0.5 & difference >= 2 & difference <= 5 ~ "pre",
             dist < 0.5 & difference >= 0 & difference <= 2 ~ "mid",
             dist < 0.5 & difference < 0 ~ "post",
             dist > 0.5 & difference >= 0 & difference <= 5 ~ "outside",
             TRUE ~ "other"
    )
  )
```

#### drop the rows that are grouped as others upon the dist data and difference


```{r}
prop_within_1mile_of <- prop_within_1mile %>% 
  filter(group != "other")
```

#### creating the Tpost column (homes within 0.5 miles of Developemnt, where sale occurred after the housing development was placed in service) for the statistical analysis and modeling. We also create a column for the Tall groups.

```{r}
prop_within_1mile_of <- prop_within_1mile_of %>%
  mutate(Tall = (YR_PIS - ownerdate),
         Tpost = if_else(group == "post", (ownerdate - YR_PIS), 0))
```

#### Filter to any property sold 5 years before development to 5 years after

```{r}
prop_sold_5yrs <- prop_within_1mile_of %>%
  filter(difference >= -5 & difference <= 5)
#summary(prop_sold_5yrs)

# converted the land_areas into numeric and tract into character
prop_sold_5yrs[c("land_area_acres", "acres")] <- str_split_fixed(prop_sold_5yrs$land_area,' ', 2)

prop_sold_5yrs <- subset(prop_sold_5yrs, select = -c(acres) )
prop_sold_5yrs$land_area_acres <- prop_sold_5yrs$land_area_acres%>%
  as.numeric()

prop_sold_5yrs$tract <- prop_sold_5yrs$tract%>%
  as.character()
str(prop_sold_5yrs)
```


### NOTE: we see that tract is numeric an land_area is character we want to change their character to do modeling.

#### Running linaer regression models

```{r}
simple_regression_model <- lm(amount ~ square_footage +  age + group + ownerdate + tract + land_area_acres, data = prop_sold_5yrs)
summary(simple_regression_model)
```
```{r}
simple_regression_model$coefficients
```
```{r}
final_df_sf <- prop_sold_5yrs%>%
  st_sf(sf_column_name = 'geometry')



```




```{r}

# Read in road centerlines data from Rohit and try to plot the property and the low income housing on it to see where the LIHTC are concentarted and which properties are closer in 0.5 miles on map maybe plot the circle around them.
roads <- st_read("./data/road_centerlines/road_centerlines.shp", as_tibble = T, quiet = T) %>%
  st_transform('+proj=longlat +datum=WGS84')

map <- leaflet() %>%
  addProviderTiles(provider = "CartoDB.Positron") %>%
  setView(lng = -86.7816, lat = 36.1627, zoom = 10) %>%
  setMaxBounds(lng1 = -86.7816 + 1,
               lat1 = 36.1627 + 1,
               lng2 = -86.7816 - 1,
               lat2 = 36.1627 - 1)

# Visualize Metro Nashville properties sold 5 years pre and post LIHTC
sf_circles <- st_buffer(dev_sf, dist = 804.5) #to create the polygon around a point

map <- leaflet(options = leafletOptions(minZoom = 8)) %>%
  addProviderTiles(provider = "CartoDB.Positron") %>%
  setView(lng = -86.7816, lat = 36.1627, zoom = 12) %>%
  setMaxBounds(lng1 = -86.7816 + 1, 
               lat1 = 36.1627 + 1, 
               lng2 = -86.7816 - 1, 
               lat2 = 36.1627 - 1) %>%
  addCircleMarkers(data = dev_sf, radius = 1)%>%
  addPolygons(data = sf_circles)
map



```

### Going to create a lat long from geometry to plot the prop_sold_5years can be ploted as map

```{r}
final_df_sf <- prop_sold_5yrs%>%
  st_sf(sf_column_name = 'geometry')

#sf_circles <- st_buffer(final_df_sf, dist = 804.5) #there is a dist column not sure if that is hurting it


map <- leaflet(options = leafletOptions(minZoom = 8)) %>%
  addProviderTiles(provider = "CartoDB.Positron") %>%
  setView(lng = -86.7816, lat = 36.1627, zoom = 12) %>%
  setMaxBounds(lng1 = -86.7816 + 1, 
               lat1 = 36.1627 + 1, 
               lng2 = -86.7816 - 1, 
               lat2 = 36.1627 - 1) %>%
  addCircleMarkers(data = final_df_sf, radius = 1)%>%
  addPolygons(data = sf_circles)%>%
  addCircleMarkers(data = prop_sales_sf,
                   radius = 1,
                   color = "white",
                   weight = 0.25,
                   fillColor = "red",
                   fillOpacity = 0.75)
map


```



```{r}
# #library(tidyverse)
# 
# df <- df %>% 
#   mutate(Geom = gsub('[()Â°]', '', Geom)) %>% 
#   separate(col = Geom, into = c('Latitude', 'Longitude '), sep = '\\,')
# 
# leaflet() %>%
#         addProviderTiles(provider = "Esri", options = providerTileOptions(maxZoom = 6)) %>%
#         
#         addCircleMarkers(
#           data = filtered_df,
#           radius = log10(filtered_df$number_of_speakers),
#           opacity = .6,
#           color = pal(filtered_df$endangerment_degree),
#           lng = ~ Longitude,
#           lat = ~ Latitude,
#           popup = popup
#         ) %>%
#         addLegend(
#           pal = pal,
#           position = 'bottomleft',
#           values = factor(filtered_df$endangerment_degree),
#           title = 'Endangerment degrees'
#         )
#       
#     })
#     
#   })


```



```{r}
prop_sold_5yrs%>%
  sample_n(1000)
```

```{r}
prop_sold_5yrs%>%
  summarise(n_distinct(PROJECT))

developments%>%
  summarise(n_distinct(PROJECT))
```

Add a new chunk by clicking the *Insert Chunk* button on the toolbar or by pressing *Ctrl+Alt+I*.

When you save the notebook, an HTML file containing the code and output will be saved alongside it (click the *Preview* button or press *Ctrl+Shift+K* to preview the HTML file).

The preview shows you a rendered HTML copy of the contents of the editor. Consequently, unlike *Knit*, *Preview* does not run any R code chunks. Instead, the output of the chunk when it was last run in the editor is displayed.
